#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    InfraCollector, sensorReflection)
#pragma config(Sensor, dgtl1,  ,               sensorDigitalOut)
#pragma config(Sensor, dgtl2,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl4,  leftSwitch,     sensorTouch)
#pragma config(Sensor, dgtl5,  rightSwitch,    sensorTouch)
#pragma config(Sensor, dgtl6,  leftButton,     sensorTouch)
#pragma config(Sensor, dgtl7,  rightButton,    sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port2,           leftMotor,     tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           armMotor,      tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port4,           rightMotor,    tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int OFF = 0; // Used to turn motor off
const int motorForwards = 30; // Speed at which motors will turn in forward direction
const int motorBackwards = -30; // Speed at which motors will turn in backward direction

const int signalThreshhold = 7; // Minimum difference between highest and lowest readings to ensure signal has been found
const int searchPeriod = 100; // Time for one series of calculations (milliseconds)
const int armMovementTime = 2000; // Time required for arm to move either fully up, or fully down

const int maxWallDistance = 6; // Maximum possible distance from wall for drop off (measured in centimetres)

int high; // Highest value read by IR collector
int low; // Lowest value read by IR collector
int wallDistance = 0; // Current Distance from Walls
int minDistance = 100; // Minimum Distance read by Sonar Sensor (Set Intentionally large to start)

typedef enum FSMState{ // This is every state the system can possibly be in
  stopped, 
  searching, //Looking For Beacon
  forwards, //Beacon Found Move in its general direction
  moveCloser, //Slower creep towards beacon
  refine, //Reposition for pickup
  align, //Align Arm
  armUp, 
  findWall, //Used for Dropoff purposes
  switchPressed, //Signals a Wall has been hit
  inCorner,
  armDown,
  signalCompletion
};

FSMState state = searching;

task main()
{
  //Initialize System
  motor[armMotor] = OFF;
  resetMotorEncoder(leftMotor);
  resetMotorEncoder(armMotor);


  while(true){

    // Used to Manually Adjust Height of Arm (Testing Purposes)
    while(SensorValue(leftButton)){
      motor[armMotor] = -40;
    }
    while(SensorValue(rightButton)){
      motor[armMotor] = 40;
    }
    motor[armMotor] = 0;


    switch(state){

      case stopped:
        motor[leftMotor] = OFF;
        motor[rightMotor] = OFF;
        motor[armMotor] = OFF;
        break;

      case searching:
        motor[rightMotor] = motorForwards;
        motor[leftMotor] = motorForwards;
        clearTimer(T1);
        high = 0;
        low = 4096;
        while(time1[T1] < searchPeriod){
          if(SensorValue(sonarSensor) > wallDistance){
            wallDistance = SensorValue(sonarSensor);
          }//end if
          if(SensorValue(InfraCollector) > high){
            high = SensorValue(InfraCollector);
          }else if(SensorValue(InfraCollector) < low){
            low = SensorValue(InfraCollector);
          }// end if else
        }//end while

        if((high - low) > signalThreshhold){
          state = forwards;
        }else if(getMotorEncoder(leftMotor) > 2000){
          state = moveCloser;
        }else{
          state = searching;
        }//end if else

        break;

      case forwards:
        resetMotorEncoder(leftMotor);
        while(SensorValue(sonarSensor) > 35){
          motor[leftMotor] = -35;
          motor[rightMotor] = 35;
        }//end while
        resetMotorEncoder(armMotor);
        motor[leftMotor] = 0;
        motor[rightMotor] = 0;
        if(getMotorEncoder(leftMotor) < -1250){
          state = refine;
        }else{
          state = align;
        }//end if else
          
        break;

      case moveCloser:
        while(SensorValue(sonarSensor) < 170){
          motor[leftMotor] = motorForwards;
          motor[rightMotor] = motorForwards;
        }//end while
        resetMotorEncoder(leftMotor);
        while(getMotorEncoder(leftMotor) > -1000){
          motor[leftMotor] = motorBackwards;
          motor[rightMotor] = motorForwards;
        }//end while
        motor[leftMotor] = OFF;
        motor[rightMotor] = OFF;
        resetMotorEncoder(leftMotor);
        state = searching;
        break;

      case refine:
        minDistance = 100;
        resetMotorEncoder(leftMotor);
        while(getMotorEncoder(leftMotor) < 200){
          motor[leftMotor] = motorForwards;
          motor[rightMotor] = motorForwards;
          if(SensorValue(sonarSensor) < minDistance){
            minDistance = SensorValue(sonarSensor);
          }//end if
        }//end while
        resetMotorEncoder(leftMotor);
        while(getMotorEncoder(leftMotor) > -400){
          motor[leftMotor] = motorBackwards;
          motor[rightMotor] = motorBackwards;    
          if(SensorValue(sonarSensor) < minDistance){
            minDistance = SensorValue(sonarSensor);
          }//end if
        }//end while
        resetMotorEncoder(leftMotor);
        while(getMotorEncoder(leftMotor) < 400){
          motor[leftMotor] = motorForwards;
          motor[rightMotor] = motorForwards;
          if(minDistance == SensorValue(sonarSensor)){
            state = align;
            break; 
          }//end if
        }//end while
        motor[leftMotor] = OFF;
        motor[rightMotor] = OFF;
        break;

      case align:
        while(SensorValue(sonarSensor) > 5){
          motor[leftMotor] = -20;
          motor[rightMotor] = 20;
        }//end while
        state = armUp;
        break;

      case armUp:
        motor[leftMotor] = 0;
        motor[rightMotor] = 0;
        clearTimer(T1);
        while(time1[T1] < armMovementTime){
            motor[armMotor] = 50;
        }//end while
        state = inCorner;
        break;

      case findWall:
        while(!SensorValue(leftSwitch) && !SensorValue(rightSwitch)){
          motor[leftMotor] = motorBackwards;
          motor[rightMotor] = motorForwards;
        }//end while
        state = switchPressed;
        break;

      case switchPressed:
        motor[leftMotor] = OFF;
        motor[rightMotor] = OFF;
        while(SensorValue(leftSwitch) && !(SensorValue(rightSwitch))){
          motor[leftMotor] = OFF;
          motor[rightMotor] = 40;
        }//end while
        while(SensorValue(rightSwitch) && !(SensorValue(leftSwitch))){
          motor[leftMotor] = -40;
          motor[rightMotor] = OFF;
        }//end while
        if(SensorValue(sonarSensor) <= maxWallDistance && SensorValue(leftSwitch) && SensorValue(rightSwitch)){
          state = armDown;
        }else if(SensorValue(leftSwitch) && SensorValue(rightSwitch)){
          wait1Msec(100);
          if(SensorValue(sonarSensor) > 5){
            state =inCorner;
          }else{
              state = armDown;
          }//end if else
        }//end if else
        break;

      case inCorner:
        resetMotorEncoder(leftMotor);
        while(getMotorEncoder(leftMotor) < 500){
          motor[leftMotor] = motorForwards;
          motor[rightMotor] = motorBackwards;
        }//end while
        resetMotorEncoder(leftMotor);
        while(getMotorEncoder(leftMotor) > -250){
          motor[leftMotor] = motorBackwards;
          motor[rightMotor] = motorBackwards;
        }//end while
        motor[leftMotor] = OFF;
        motor[rightMotor] = OFF;
        state = findWall;
        break;

      case armDown:
        motor[leftMotor] = OFF;
        motor[rightMotor] = OFF;
        clearTimer(T1);
        while(time1[T1] < armMovementTime){
          motor[armMotor] = - 40;
        }//end while
        state = signalCompletion;
        break;
          
      case signalCompletion:
        clearTimer(T1);
        while(time1[T1] < 2000){
          motor[leftMotor] = motorForwards;
          motor[rightMotor] = motorBackwards;
        }//end while
        while(time1[T1] < 3000){
          motor[leftMotor] = -100;
          motor[rightMotor] = -100;
        }//end while
        state = stopped;
        break;
    }//end switch
  }//end while
}// end main